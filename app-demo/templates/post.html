{% extends "base.html" %}

{% block page_title %}Post by {{ post.author.full_name or post.author.username }}{% endblock %} {# Keep username as fallback if full_name somehow missing for old data #}

{% block header_title %}Post by {{ post.author.full_name or post.author.username }}{% endblock %}

{% block content %}
<div class="post-view"> {# Removed adw-clamp content-clamp as base.html provides clamp #}
    <article class="post-article adw-card blog-content-card"> {# Added adw-card and specific class #}
        <header class="post-header">
            {# Title h1 removed #}
            <div class="post-meta-detail">
                <p class="adw-label body">
                    By: <a href="{{ url_for('profile.view_profile', user_id=post.author.id) }}" class="adw-link">{{ post.author.full_name or post.author.username if post.author else 'Unknown Author' }}</a>&nbsp;
                    {%- if post.published_at -%}
                        on <time datetime="{{ post.published_at.isoformat() }}">{{ post.published_at | human_readable_date }}</time>
                    {%- else -%} {# Should not happen for new posts, fallback for old data or if published_at was somehow not set #}
                        on <time datetime="{{ post.created_at.isoformat() }}">{{ post.created_at | human_readable_date }}</time>
                    {%- endif -%}
                </p>
                {% set updated_str = post.updated_at | human_readable_date %}
                {% set created_str = (post.published_at or post.created_at) | human_readable_date %}

                {% if post.updated_at and updated_str != created_str %}
                    <p class="adw-label caption last-updated">(Last updated: <time datetime="{{ post.updated_at.isoformat() }}">{{ updated_str }}</time>)</p>
                {% endif %}
            </div>

            {% if post.categories %}
            <div class="post-terms post-categories">
                <strong class="adw-label caption post-meta-terms-label">Categories:</strong>
                {% for category in post.categories %}
                    <a href="{{ url_for('post.posts_by_category', category_slug=category.slug) }}" class="adw-button flat compact">{{ category.name }}</a>
                {% endfor %}
            </div>
            {% endif %}

            {% if post.tags %}
            <div class="post-terms post-tags">
                <strong class="adw-label caption post-meta-terms-label">Tags:</strong>
                {% for tag in post.tags %}
                  <a href="{{ url_for('post.posts_by_tag', tag_slug=tag.slug) }}" class="adw-button flat compact tag-pill">{{ tag.name }}</a>
                {% endfor %}
            </div>
            {% endif %}
        </header>

        <div class="post-content styled-text-content"> {# Added styled-text-content for prose styling #}
            {{ post.content | markdown }}
        </div>

        {# Likes and Actions Section - Placed before Author Bio for prominence #}
        <footer class="adw-card__actions post-interaction-footer" style="padding-top: var(--spacing-m); margin-top: var(--spacing-m); border-top: 1px solid var(--border-color);">
            <div class="like-section adw-box adw-box-horizontal adw-box-spacing-s align-center">
                {% if current_user.is_authenticated %}
                    {% if current_user.has_liked_post(post) %}
                        <form action="{{ url_for('post.unlike_post_route', post_id=post.id) }}" method="POST" style="display: inline;">
                            <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
                            <button type="submit" class="adw-button flat" aria-label="Unlike post"> {# Keep it neutral, not destructive for "unlike" #}
                                <span class="adw-icon icon-actions-starred-symbolic"></span> Liked
                            </button>
                        </form>
                    {% else %}
                        <form action="{{ url_for('post.like_post_route', post_id=post.id) }}" method="POST" style="display: inline;">
                            <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
                            <button type="submit" class="adw-button flat suggested-action" aria-label="Like post">
                                <span class="adw-icon icon-actions-star-symbolic"></span> Like
                            </button>
                        </form>
                    {% endif %}
                {% else %} {# If user not logged in, show a disabled-like or link to login #}
                    <a href="{{ url_for('auth.login', next=request.url) }}" class="adw-button flat">
                        <span class="adw-icon icon-actions-star-symbolic"></span> Like
                    </a>
                {% endif %}
                <span class="adw-label caption like-count">{{ post.likers.count() }} like{% if post.likers.count() != 1 %}s{% endif %}</span>
            </div>
            {# Space for other actions like share, if not in a separate section #}
        </footer>

        {% if post.author %}
        <section class="author-bio-section adw-card">
            <h3 class="adw-title-3">About {{ post.author.full_name }}</h3>
            <div class="adw-box adw-box-spacing-m author-bio-content">
                <span class="adw-avatar size-large">
                     {% set author_avatar = url_for('static', filename=post.author.profile_photo_url) if post.author.profile_photo_url else url_for('static', filename='img/default_avatar.png') %}
                     <img src="{{ author_avatar }}" alt="{{ post.author.full_name }} avatar" class="adw-avatar__image">
                </span>
                <div class="author-bio-text-content">
                    {% if post.author.profile_info %}
                    <p class="adw-label body author-bio-text">
                        {{ post.author.profile_info | safe }}
                    </p>
                    {% else %}
                    <p class="adw-label body author-bio-text-placeholder">This author has not provided a bio yet.</p>
                    {% endif %}
                    <a href="{{ url_for('profile.view_profile', user_id=post.author.id) }}" class="adw-button flat view-profile-button">View Profile of {{ post.author.full_name }}</a>
                </div>
            </div>
        </section>
        {% endif %}

        {% if post.author == current_user %}
        <div class="post-actions-container adw-box adw-box-spacing-s">
            <a href="{{ url_for('post.edit_post', post_id=post.id) }}" class="adw-button">Edit Post</a>
            <button id="open-delete-dialog-btn" class="adw-button destructive-action">Delete Post</button>
        </div>

    <adw-dialog id="delete-confirm-dialog" title="Confirm Deletion">
        {# Default header with title is handled by the web component based on 'title' attribute #}
        {# Or, we can provide a custom header slot if needed:
        <header slot="header" class="adw-header-bar adw-dialog__header">
             <h2 class="adw-header-bar__title">Confirm Deletion</h2>
            </header>
        #}
        <div slot="content" class="adw-dialog-content">
                <p class="adw-label body">Are you sure you want to delete this post? This action cannot be undone.</p>
            </div>
        <div slot="buttons" class="adw-dialog-footer">
                <button id="cancel-delete-btn" class="adw-button flat">Cancel</button>
                <form method="POST" action="{{ url_for('post.delete_post', post_id=post.id) }}" id="delete-post-form" class="delete-post-form-inline">
                    {{ delete_post_form.hidden_tag() }} {# Use form instance for CSRF #}
                    <button id="confirm-delete-btn" type="submit" class="adw-button destructive-action">Delete</button>
                </form>
        </div>
    </adw-dialog>
        {% endif %}
    </article>

    <hr class="section-divider">

    {# Macro to render a single comment and its replies recursively #}
    {% macro render_comment_with_replies(comment, post, delete_comment_form, current_user, form, is_reply=false) %}
    <div class="comment-item {% if is_reply %}comment-reply-item{% else %}comment-top-level-item{% endif %}"
         id="comment-{{ comment.id }}"
         {% if is_reply %}style="margin-left: 30px; margin-top: var(--spacing-s); padding-top: var(--spacing-s); border-top: 1px dashed var(--divider-color);"{% endif %}>

        <header class="comment-header adw-box adw-box-spacing-s comment-header-box">
            <span class="adw-avatar size-medium">
               {% set comment_avatar = url_for('static', filename=comment.author.profile_photo_url) if comment.author.profile_photo_url else default_avatar_url %}
               <img src="{{ comment_avatar }}" alt="{{ comment.author.full_name }} avatar" class="adw-avatar__image">
            </span>
            <div class="comment-author-meta">
                 <a href="{{ url_for('profile.view_profile', user_id=comment.author.id) }}" class="adw-link comment-author-link-strong">{{ comment.author.full_name }}</a>
                <small class="adw-label caption comment-timestamp"><time datetime="{{ comment.created_at.isoformat() }}">{{ comment.created_at | human_readable_date }}</time></small>
            </div>
        </header>
        <div class="comment-text styled-text-content">{{ comment.text | markdown }}</div>

        <div class="comment-actions">
            {% if current_user.is_authenticated %}
            <button class="adw-button flat compact reply-button" data-comment-id="{{ comment.id }}" data-comment-author="{{ comment.author.full_name | e }}">Reply</button>
            {% endif %}
            {% if current_user.is_authenticated and comment.author != current_user %}
                {% if comment.is_flagged_active %}
                    <button class="adw-button flat compact" disabled title="This comment has been flagged">Flagged</button>
                {% else %}
                    <form method="POST" action="{{ url_for('post.flag_comment', comment_id=comment.id) }}" style="display: inline;">
                        {{ flag_comment_form.hidden_tag() }} {# Use the correct form instance #}
                        <button type="submit" class="adw-button flat compact" title="Flag this comment for review">Flag</button>
                    </form>
                {% endif %}
            {% endif %}
            {% if current_user.is_authenticated and (comment.author == current_user or post.author == current_user or current_user.is_admin) %}
            {# Modified for Adwaita dialog: button type is 'button', not 'submit'. JS will handle form submission. #}
            <form method="POST" action="{{ url_for('post.delete_comment', comment_id=comment.id) }}" style="display: inline;" class="comment-delete-form" id="delete-comment-form-{{ comment.id }}">
                {{ delete_comment_form.hidden_tag() }}
                <button type="button" class="adw-button destructive-action compact comment-delete-button" data-form-id="delete-comment-form-{{ comment.id }}" data-comment-id="{{ comment.id }}">Delete</button>
            </form>
            {% endif %}
        </div>
        <div class="reply-form-container" id="reply-form-for-{{ comment.id }}" style="display: none; margin-top: var(--spacing-s);">
            {# Reply form will be injected here by JS #}
        </div>

        {# Recursively render replies within this comment's div #}
        {% if comment.replies.count() > 0 %}
            <div class="comment-replies-container" style="margin-top: var(--spacing-s);">
                {% for reply_comment in comment.replies %}
                    {{ render_comment_with_replies(reply_comment, post, delete_comment_form, current_user, form, is_reply=true) }}
                {% endfor %}
            </div>
        {% endif %}
    </div>
    {% endmacro %}

    <section class="comments-section" aria-labelledby="comments-heading">
        <h2 id="comments-heading" class="adw-title-2">Comments ({{ post.comments.count() }})</h2>
        {% if post.comments.first() %}
            <div class="adw-list-box comments-list flat">
                {% for comment in post.comments %} {# Iterates over top-level comments #}
                    <article class="adw-card comment-card" id="comment-card-for-{{ comment.id }}"> {# Each top-level comment is a card #}
                        {{ render_comment_with_replies(comment, post, delete_comment_form, current_user, form, is_reply=false) }}
                    </article>
                {% endfor %}
            </div>
        {% else %}
            <p class="adw-label body">No comments yet.</p>
        {% endif %}
    </section>

    {% if current_user.is_authenticated %}
    <section class="comment-form-section adw-list-box form-section" aria-labelledby="leave-comment-heading" style="margin-top: var(--spacing-l);">
         <header class="adw-list-box-header">
            <h3 id="leave-comment-heading" class="adw-title-3">Leave a Comment</h3>
        </header>
        <form method="POST" action="{{ url_for('post.view_post', post_id=post.id) }}" class="stacked-form" id="main-comment-form" style="padding: var(--spacing-m);">
            {{ form.hidden_tag() }} {# Flask-WTF CSRF token #}
            {{ form.parent_id(id="main_parent_id_input", type="hidden") }} {# Hidden field for parent_id #}

            {# Using a structure similar to create_post for consistency #}
            <div class="adw-action-row column-layout {{ 'has-error' if form.text.errors else '' }}">
                <label for="{{ form.text.id or 'comment_text_input' }}" class="adw-action-row-title" style="margin-bottom: var(--spacing-xs);">{{ form.text.label.text }}</label>
                {% if form.text.errors %}
                    <span class="adw-action-row-subtitle error-text" style="margin-bottom: var(--spacing-xs);">{{form.text.errors|join(' ')}}</span>
                {% endif %}

                <markdown-toolbar for="{{ form.text.id or 'comment_text_input' }}" class="custom-toolbar">
                    <md-bold>Bold</md-bold>
                    <md-italic>Italic</md-italic>
                    <md-strikethrough>Strike</md-strikethrough>
                    <md-header>Heading</md-header>
                    <md-quote>Quote</md-quote>
                    <md-code>Code</md-code>
                    <md-link>Link</md-link>
                    <md-image>Image/GIF</md-image> {# Users will paste URL for image/GIF #}
                    <md-unordered-list>List</md-unordered-list>
                    <md-ordered-list>Ordered List</md-ordered-list>
                </markdown-toolbar>
                <textarea name="{{ form.text.name }}" id="{{ form.text.id or 'comment_text_input' }}" class="adw-entry" rows="6" style="width: 100%; min-height: 120px; box-sizing: border-box; margin-top: var(--spacing-xs);">{{ form.text.data or ''}}</textarea>
            </div>

            <div class="form-actions-container form-actions-end comment-form-actions" style="margin-top: var(--spacing-m); padding: 0;"> {# Simplified padding as form has it now #}
                 <button type="submit" class="adw-button suggested-action">{{ form.submit.label.text }}</button>
            </div>
        </form>
    </section>
    {% else %}
    <div class="login-prompt-comment">
        <p class="adw-label body"><a href="{{ url_for('auth.login', next=request.url) }}" class="adw-link">Login</a> to leave a comment.</p>
    </div>
    {% endif %}

    {% if related_posts %}
    <section class="related-posts-section related-posts-container" aria-labelledby="related-posts-heading">
        <h2 id="related-posts-heading" class="adw-title-2">Related Posts</h2>
        <div class="adw-list-box">
            {% for related_post in related_posts %}
            <a href="{{ url_for('post.view_post', post_id=related_post.id) }}" class="adw-action-row activatable">
                <div class="adw-action-row-content">
                    <span class="adw-action-row-title">Post by {{ related_post.author.full_name or related_post.author.username }}</span>
                    {% if related_post.content %}
                    <span class="adw-action-row-subtitle">{{ related_post.content | striptags | truncate(80) }}</span>
                    {% endif %}
                </div>
                <span class="adw-action-row__chevron"></span>
            </a>
            {% endfor %}
        </div>
    </section>
    {% endif %}

    <div class="adw-box adw-box-spacing-s back-to-posts-container">
         <a href="{{ url_for('general.index') }}" class="adw-button"><span class="adw-icon icon-actions-go-previous-symbolic"></span> Back to Posts</a>
    </div>

    {# Dialog for confirming comment deletion - now using <adw-dialog> #}
    <adw-dialog id="delete-comment-confirm-dialog" title="Confirm Comment Deletion">
        <div slot="content" class="adw-dialog-content">
            <p class="adw-label body">Are you sure you want to delete this comment? This action cannot be undone.</p>
        </div>
        <div slot="buttons" class="adw-dialog-footer">
            <button id="cancel-comment-delete-btn" class="adw-button flat">Cancel</button>
            <form method="POST" action="" id="confirm-delete-comment-form-actual" style="display: inline;">
                 {{ delete_comment_form.hidden_tag() }}
                <button id="confirm-comment-delete-btn" type="submit" class="adw-button destructive-action">Delete Comment</button>
            </form>
        </div>
    </adw-dialog>
</div>

<script>
// Threaded comments reply script & post/comment dialog logic is now primarily handled by app-layout.js
// Any page-specific variations or initializations needed beyond global handlers can go here.
// For post.html, the dialogs (delete post, delete comment) are expected to be handled by app-layout.js.

document.addEventListener('DOMContentLoaded', () => {
    // Specific logic for comment deletion dialog on this page, if different from global app-layout.js
    // This example assumes app-layout.js handles the #delete-comment-confirm-dialog
    // and its trigger buttons (.comment-delete-button) correctly.
    // If post.html's comment deletion needs unique handling not covered by app-layout's generic setup, add here.
    // For now, we assume app-layout.js covers it.

    // Threaded comments reply script
    const mainCommentForm = document.getElementById('main-comment-form');
    if (!mainCommentForm) return; // If no comment form, do nothing

    const mainParentIdInput = document.getElementById('main_parent_id_input');
    const mainCommentTextArea = mainCommentForm.querySelector('textarea[name="text"]');
    const mainCommentSubmitButton = mainCommentForm.querySelector('button[type="submit"]');
    const mainCommentLabel = mainCommentForm.querySelector('label[for="' + (mainCommentTextArea ? mainCommentTextArea.id : '') + '"]');
    const originalFormContainer = mainCommentForm.parentElement; // Store original parent

    document.querySelectorAll('.reply-button').forEach(button => {
        button.addEventListener('click', () => {
            const commentId = button.dataset.commentId;
            const commentAuthor = button.dataset.commentAuthor || 'user';
            const replyFormContainer = document.getElementById(`reply-form-for-${commentId}`);

            if (!replyFormContainer) return;

            // Detach form from current parent before appending to new one
            if (mainCommentForm.parentElement) {
                mainCommentForm.parentElement.removeChild(mainCommentForm);
            }

            replyFormContainer.appendChild(mainCommentForm);
            if(mainParentIdInput) mainParentIdInput.value = commentId;
            if(mainCommentSubmitButton) mainCommentSubmitButton.textContent = 'Post Reply';
            if(mainCommentLabel) mainCommentLabel.textContent = `Reply to ${commentAuthor}`;
            if(mainCommentTextArea) {
                mainCommentTextArea.placeholder = `Replying to ${commentAuthor}...`;
                mainCommentTextArea.focus();
            }
            replyFormContainer.style.display = 'block';

            // Hide other reply forms that might have been opened
            document.querySelectorAll('.reply-form-container').forEach(container => {
                if (container.id !== replyFormContainer.id) {
                    container.style.display = 'none';
                    // Do not clear their content if they didn't have the main form
                }
            });
        });
    });

    // Logic to move the form back if user clicks the main "Leave a Comment" section header
    const mainCommentSectionHeader = document.getElementById('leave-comment-heading');
    if(mainCommentSectionHeader && originalFormContainer) {
        mainCommentSectionHeader.addEventListener('click', (event) => {
            // Prevent if the click is on the form itself if it's already there
            if (originalFormContainer.contains(event.target) && event.target !== mainCommentSectionHeader) {
                return;
            }

            if (mainCommentForm.parentElement !== originalFormContainer) {
                if (mainCommentForm.parentElement) { // Detach if attached elsewhere
                    mainCommentForm.parentElement.removeChild(mainCommentForm);
                }
                originalFormContainer.appendChild(mainCommentForm);
                if(mainParentIdInput) mainParentIdInput.value = '';
                if(mainCommentSubmitButton) mainCommentSubmitButton.textContent = 'Post Comment';
                if(mainCommentLabel) mainCommentLabel.textContent = 'Comment';
                if(mainCommentTextArea) mainCommentTextArea.placeholder = 'Enter your comment here...';

                document.querySelectorAll('.reply-form-container').forEach(container => {
                    container.style.display = 'none';
                });
            }
        });
    }
});
</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
    const setupMentionAutocomplete = (textareaElement, parentForm) => {
        let mentionQuery = '';
        let isMentioning = false;
        let suggestionsBox = null;
        let suggestionRequestTimeout = null;

        const createSuggestionsBox = () => {
            if (suggestionsBox) suggestionsBox.remove();
            suggestionsBox = document.createElement('div');
            suggestionsBox.className = 'adw-popover menu-popover mention-suggestions-popover'; // Re-use popover styling
            suggestionsBox.style.position = 'absolute';
            suggestionsBox.style.zIndex = '1000';
            // suggestionsBox.style.border = '1px solid #ccc';
            // suggestionsBox.style.background = 'var(--secondary-bg-color)'; // Use Adwaita variable
            // suggestionsBox.style.maxHeight = '150px';
            // suggestionsBox.style.overflowY = 'auto';
            // suggestionsBox.style.minWidth = textareaElement.offsetWidth + 'px';
            textareaElement.parentNode.insertBefore(suggestionsBox, textareaElement.nextSibling);

            // Position relative to textarea
            const rect = textareaElement.getBoundingClientRect();
            const parentRect = textareaElement.offsetParent ? textareaElement.offsetParent.getBoundingClientRect() : { top: 0, left: 0 };

            suggestionsBox.style.top = (rect.bottom - parentRect.top + window.scrollY) + 'px';
            suggestionsBox.style.left = (rect.left - parentRect.left + window.scrollX) + 'px';
            suggestionsBox.style.minWidth = rect.width + 'px';

            return suggestionsBox;
        };

        const fetchSuggestions = async (query) => {
            if (!query) {
                if (suggestionsBox) suggestionsBox.style.display = 'none';
                return;
            }
            try {
                const response = await fetch(`/user/mention_suggestions?q=${encodeURIComponent(query)}`);
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                const users = await response.json();
                displaySuggestions(users);
            } catch (error) {
                console.error('Error fetching mention suggestions:', error);
                if (suggestionsBox) suggestionsBox.style.display = 'none';
            }
        };

        const displaySuggestions = (users) => {
            if (!suggestionsBox) suggestionsBox = createSuggestionsBox();
            suggestionsBox.innerHTML = ''; // Clear previous suggestions

            if (users.length === 0) {
                suggestionsBox.style.display = 'none';
                return;
            }

            const listBox = document.createElement('div');
            listBox.className = 'adw-list-box flat popover-list-box'; // Use Adwaita list box styling

            users.forEach(user => {
                const userRow = document.createElement('button'); // Use button for focus and click
                userRow.className = 'adw-action-row activatable'; // Adwaita action row
                userRow.type = 'button'; // Important for forms
                userRow.style.textAlign = 'left'; // Ensure text aligns left

                const avatarSpan = document.createElement('span');
                avatarSpan.className = 'adw-avatar size-s'; // Small avatar
                avatarSpan.style.marginRight = 'var(--spacing-s)';
                const avatarImg = document.createElement('img');
                avatarImg.src = user.profile_photo_url ? '{{ url_for("static", filename="") }}' + user.profile_photo_url : '{{ default_avatar_url }}';
                avatarImg.alt = user.full_name + ' avatar';
                avatarSpan.appendChild(avatarImg);

                const textContentDiv = document.createElement('div');
                textContentDiv.className = 'adw-action-row-text-content';

                const titleSpan = document.createElement('span');
                titleSpan.className = 'adw-action-row-title';
                titleSpan.textContent = user.full_name;

                textContentDiv.appendChild(titleSpan);

                userRow.appendChild(avatarSpan);
                userRow.appendChild(textContentDiv);

                userRow.addEventListener('click', () => {
                    const currentText = textareaElement.value;
                    const atIndex = currentText.lastIndexOf('@', textareaElement.selectionStart -1);
                    if (atIndex !== -1) {
                        const textBefore = currentText.substring(0, atIndex);
                        const textAfter = currentText.substring(textareaElement.selectionStart);
                        // Replace spaces in full_name with something or handle differently if spaces not allowed in mentions
                        textareaElement.value = textBefore + `@${user.full_name} ` + textAfter;
                        isMentioning = false;
                        mentionQuery = '';
                        suggestionsBox.style.display = 'none';
                        textareaElement.focus();
                        // Move cursor after the inserted mention
                        const newCursorPos = (textBefore + `@${user.full_name} `).length;
                        textareaElement.setSelectionRange(newCursorPos, newCursorPos);
                    }
                });
                listBox.appendChild(userRow);
            });
            suggestionsBox.appendChild(listBox);
            suggestionsBox.style.display = 'block';
        };

        textareaElement.addEventListener('input', (e) => {
            const cursorPos = textareaElement.selectionStart;
            const textBeforeCursor = textareaElement.value.substring(0, cursorPos);
            const atMatch = textBeforeCursor.match(/@(\w*)$/);

            if (atMatch) {
                isMentioning = true;
                mentionQuery = atMatch[1];
                if (!suggestionsBox || suggestionsBox.style.display === 'none') {
                    createSuggestionsBox(); // Create/re-create if hidden
                }

                clearTimeout(suggestionRequestTimeout);
                suggestionRequestTimeout = setTimeout(() => {
                    fetchSuggestions(mentionQuery);
                }, 300); // Debounce API calls

            } else {
                isMentioning = false;
                mentionQuery = '';
                if (suggestionsBox) {
                    suggestionsBox.style.display = 'none';
                }
            }
        });

        textareaElement.addEventListener('keydown', (e) => {
            if (isMentioning && suggestionsBox && suggestionsBox.style.display === 'block') {
                const suggestions = suggestionsBox.querySelectorAll('.adw-action-row');
                if (suggestions.length > 0) {
                    let currentIndex = Array.from(suggestions).findIndex(s => s === document.activeElement);
                    if (e.key === 'ArrowDown') {
                        e.preventDefault();
                        currentIndex = (currentIndex + 1) % suggestions.length;
                        suggestions[currentIndex].focus();
                    } else if (e.key === 'ArrowUp') {
                        e.preventDefault();
                        currentIndex = (currentIndex - 1 + suggestions.length) % suggestions.length;
                        suggestions[currentIndex].focus();
                    } else if (e.key === 'Enter' && currentIndex !== -1) {
                        e.preventDefault();
                        suggestions[currentIndex].click();
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        suggestionsBox.style.display = 'none';
                        isMentioning = false;
                    }
                }
            }
        });

        // Hide suggestions if textarea loses focus, unless focus moves to a suggestion
        textareaElement.addEventListener('blur', () => {
            // Delay hiding to allow click on suggestion
            setTimeout(() => {
                if (suggestionsBox && !suggestionsBox.contains(document.activeElement)) {
                    suggestionsBox.style.display = 'none';
                }
            }, 100);
        });

    };

    // Setup for the main comment form
    const mainCommentTextArea = document.getElementById('{{ form.text.id or "comment_text_input" }}');
    const mainCommentFormElement = document.getElementById('main-comment-form');
    if (mainCommentTextArea && mainCommentFormElement) {
        setupMentionAutocomplete(mainCommentTextArea, mainCommentFormElement);
    }

    // Setup for reply forms (dynamically added or existing ones if any)
    // This part needs to be robust if reply forms are added/removed.
    // For now, let's assume they might exist on load or are added in a way that this can be re-triggered.
    // A MutationObserver on the comments section could make this more dynamic.
    document.querySelectorAll('.reply-form-container textarea').forEach(replyTextarea => {
        const replyForm = replyTextarea.closest('form'); // Assuming textarea is inside a form
        if(replyForm){
            setupMentionAutocomplete(replyTextarea, replyForm);
        }
    });

    // Re-initialize for reply form when it's moved
    const originalSetupReplyForm = (commentId) => {
        const replyFormContainer = document.getElementById(`reply-form-for-${commentId}`);
        if (replyFormContainer) {
            const replyTextarea = replyFormContainer.querySelector('textarea[name="text"]');
            const replyForm = replyTextarea ? replyTextarea.closest('form') : null;
            if (replyTextarea && replyForm && !replyTextarea.dataset.mentionInitialized) { // Avoid re-initializing
                setupMentionAutocomplete(replyTextarea, replyForm);
                replyTextarea.dataset.mentionInitialized = 'true';
            }
        }
    };

    document.querySelectorAll('.reply-button').forEach(button => {
        button.addEventListener('click', () => {
            const commentId = button.dataset.commentId;
            // When the main form is moved to a reply section, its textarea ID remains the same.
            // The setupMentionAutocomplete is already called for the main form's textarea.
            // We need to ensure the suggestionsBox is repositioned if the form moves.
            // The current createSuggestionsBox() is called on input, which recalculates position.
            // However, we might need to ensure the old suggestionsBox instance is removed or correctly handled.
            // The simplest for now: the main form's JS will continue to work.
            // If reply forms were separate elements, we'd call originalSetupReplyForm(commentId) here.
            // Since we move the *same* form, its event listeners persist.
            // The key is that createSuggestionsBox() is called on next @ input.
        });
    });

});
</script>

{% block scripts %}
{{ super() }}
<script type="module" src="https://cdn.jsdelivr.net/npm/@github/markdown-toolbar-element@1.0.3/dist/index.umd.js" nonce="{{ csp_nonce() if csp_nonce else '' }}"></script>
{% endblock %}
